/* */

export const texto100 = `La metodología para el desarrollo del proyecto se basará en SCRUM, 
el cual está basado en un enfoque iterativo e incremental, permitiendo la flexibilidad necesaria 
para adaptarse a las necesidades cambiantes del proyecto.`
export const texto101 = `Scrum es un marco de trabajo ágil utilizado para gestionar y desarrollar proyectos complejos, especialmente
en el ámbito del software. Se basa en principios de colaboración, autoorganización y mejora continua.
`
export const texto102 = `Se basa en la metodología ágil y ayuda a los equipos a estructurar y gestionar el trabajo a través
de un conjunto de valores, principios y prácticas.`

export const texto2 = `Análisis de requerimientos de la aplicación a desarrollar`;

export const texto2a = `
La fase de levantamiento de requerimientos comprende la base del proyecto en la cual se debe identificar, 
comprender y documentar las necesidades de los usuarios, las funcionalidades de la aplicación y 
las características técnicas que debe cumplir.`;

export const texto2b = `
Para esta fase es necesario realizar las siguientes sub-fases:
Comprender las necesidades de los usuarios.
Definir funcionalidades del sistema.
Especificar las características técnicas (definición de diagrama de clases).`;

export const texto2c = `

Los requerimientos y funcionalidades de la aplicación definidos son la base para el flujo de la aplicación, la cual se diseña gráficamente antes de iniciar con la programación. Existen diferentes herramientas que permiten el diseño de mockups estáticos e interactivos, como por ejemplo Figma.`;

export const texto2d = `
Para esta fase es necesario realizar las siguientes sub-fases:
Desarrollo de mockup.`;

export const texto2e = `
`;

export const texto2f = `
-Requerimiento de hardware:
-Procesador: 2.5 GHz o superior
-Memoria RAM: 16 GB mínimo
-Espacio en disco: 256 GB SSD mínimo
-Sistema operativo:
-Windows 10 64-bit (build 19043 o posterior)
-macOS 10.10 o posterior
-Ubuntu 18.04 o posterior`;

export const texto2g = `
-Requerimiento de software:
-IDE: Visual Studio Code
-Control de versiones: Git
-Frameworks: Angular, React, Spring Boot, Django, Express.js, Vue.js
-Bases de datos: MongoDB, PostgreSQL
-Contenedores: Docker, Docker Compose
-Servidor web: Nginx`;

export const texto2h = `
Estas herramientas son comúnmente utilizadas en el desarrollo de aplicaciones modernas y proporcionan un entorno consistente y controlado para el desarrollo y la implementación de la aplicación.`;

export const texto2i = `
Diseño de arquitectura de la aplicación
Para el desarrollo de aplicaciones basadas en una arquitectura Cliente-Servidor, se facilita el manejo de las tecnologías de lógica de negocios y la interfaz de usuario, ya que se comunican de manera efectiva para establecer el flujo de datos necesarios para el funcionamiento de una aplicación.`;

export const texto2j = `
Se elige este tipo de arquitectura específicamente porque permite que mediante el protocolo HTTP y el formato JSON todas las aplicaciones implementadas puedan ser consumidas por clientes diversos, lo que facilita el acceso a la lógica de negocios desde cualquier parte mediante internet.`;

export const texto2k = `
Para esta fase es necesario realizar las siguientes sub-fases:
-Selección de tecnologías para el frontend
-Selección de tecnologías para el backend
-Selección de bases de datos`;

export const texto2l = `
Facilitan la mantenibilidad y manipulación del código, permiten escalabilidad, separan las responsabilidades y facilitan la detección y corrección de errores. Según el programador, puede variar el patrón de diseño implementado, además de que está sujeto a cómo funciona la tecnología.`;

export const texto2m = `
Para esta fase es necesario realizar la siguiente sub-fase:
Selección de patrones de diseño`;

export const texto2n = `

La seguridad para un proyecto es de vital importancia. No es posible proveer al usuario una experiencia de alta calidad al utilizar la aplicación si no se puede garantizar la seguridad de sus datos y del sistema en sí.`;

export const texto2o = `
Para esta fase es necesario realizar la siguiente sub-fase:
Identificar algunas buenas prácticas de seguridad para el acceso remoto a los servidores, controlar el flujo del tráfico entre los clientes y servidores, manejo y autenticación de usuarios en la aplicación.`;

export const texto2p = `
A continuación, se listan algunos ejemplos:
a. SSH (Secure Shell): Se selecciona cuando se necesita un acceso remoto seguro a los servidores. 
Es útil cuando se requiere administrar los servidores remotos o transferir archivos de manera segura.
b. Reverse Proxy: Se elige cuando se necesita controlar y optimizar el flujo de tráfico entre los clientes y los servidores. Es útil para balancear la carga, proporcionar seguridad adicional y mejorar la velocidad y eficiencia de las aplicaciones web.
c. NoSQL: Se selecciona cuando se trabaja con grandes volúmenes de datos distribuidos. Es útil cuando los datos no se ajustan a un esquema rígido, se necesitan escalabilidad horizontal y alta disponibilidad, o se requiere un rendimiento rápido con grandes volúmenes de datos.
d. JWT (JSON Web Token): Se elige cuando se necesita manejar la autenticación o autorización de los usuarios en la aplicación. Es útil cuando se requiere una manera segura de transmitir información entre partes como la identidad de usuario, los roles y los privilegios.`;

export const texto2q = `

Para esta fase es necesario realizar las siguientes sub-fases:
Implementación de buenas prácticas de codificación
Implementación de los patrones de diseño
Implementación de buenas prácticas de seguridad con JWT
Desarrollo del front-end
Desarrollo del back-end
Integración del back-end y front-end`;

export const texto2r = `


Para esta fase es necesario realizar la siguiente sub-fase:
Pruebas unitarias: Verifican la precisión de un bloque de código aislado.
Pruebas de integración: Evalúan cómo interactúan varios módulos de software.
Pruebas de aceptación: Verifican si un sistema cumple con los requisitos empresariales.`;

export const texto2s = `


El despliegue es una etapa esencial en el desarrollo de software que implica la transición de aplicaciones a producción. Para esta fase es necesario realizar las siguientes sub-fases:
Contenedores`;

export const texto2t = `
Los contenedores ofrecen varias ventajas que los convierten en una opción ideal para el despliegue moderno:
Aislamiento: Las aplicaciones se ejecutan en entornos aislados, evitando conflictos y problemas de compatibilidad.
Portabilidad: Se pueden implementar en diferentes entornos, desde servidores locales hasta nubes públicas.
Escalabilidad: Se pueden escalar fácilmente para satisfacer las demandas cambiantes de tráfico y carga de trabajo.
Agilidad: Agilizan el proceso de despliegue, ya que no requieren la instalación de un sistema operativo completo para cada aplicación.`;

export const texto2u = `


Infraestructura confiable: El servidor web cuenta con una infraestructura robusta y confiable para garantizar la disponibilidad y el rendimiento óptimos de la aplicación.
Conectividad de alta velocidad: Una conexión a Internet de alta velocidad es esencial para garantizar un acceso rápido y fluido a la aplicación por parte de los usuarios.
Seguridad sólida: El servidor web cuenta con medidas de seguridad sólidas para proteger la aplicación y los datos de los usuarios contra amenazas cibernéticas.
Escalabilidad: El proveedor de alojamiento web ofrece opciones de escalabilidad para que la infraestructura pueda adaptarse al crecimiento de la aplicación y la demanda de los usuarios.`;

export const texto2v = `


Mayor velocidad: Automatizan tareas repetitivas, permitiendo a los equipos desarrollar y entregar software con mayor rapidez.
Mejor calidad: La automatización de las pruebas ayuda a identificar y corregir errores antes de que se implementen en producción.
Mayor confiabilidad: Garantizan un proceso de despliegue consistente y confiable, lo que reduce el riesgo de errores y fallos.
Mayor colaboración: Facilitan la colaboración entre equipos de desarrollo y operaciones.`;


export const texto3 = `
La metodología a utilizar está basada en el enfoque iterativo e incremental “SCRUM”. El proyecto consiste en el diseño de una guía estructurada sobre las fases para el desarrollo de este proyecto, basado en las arquitecturas integrales utilizando un desarrollo multicapa, para lo cual se realizará un ejemplo práctico de una aplicación “To-do List” llamada Flytask, que permite la gestión de tareas por parte del usuario final.`;

export const texto3a = `
Fases para el desarrollo de un proyecto
Análisis de requerimientos de la aplicación a desarrollar
Flytask es una aplicación web que permite a los usuarios crear una cuenta y administrar sus tareas de manera simple y eficiente.`;

export const texto3b = `
Identificación de funcionalidades para Flytask
Crear tareas:
Agregar título, descripción y fecha límite a la tarea.`;

export const texto3c = `
Editar tareas:
Modificar el título, descripción y fecha límite de la tarea existente.`;

export const texto3d = `
Eliminar tareas:
Eliminar las tareas que ya no son necesarias.`;

export const texto3e = `
Organizar tareas:
Clasificar las tareas según los estados proporcionados por la aplicación: Upcoming, ToDo, Doing, Done.`;

export const texto3f = `
Ver el historial de tareas:
Visualizar las tareas completadas o pendientes.`;

export const texto3g = `
Aplicar filtros:
Filtrar tareas por estado, nombre y fecha de creación.`;

export const texto3h = `
Administrar mi perfil:
Cambiar la información de perfil desde el módulo My Account.`;

export const texto3i = `
Definición diagrama de clases
La aplicación web está diseñada para poder consultar una base de datos relacional y una no relacional.`;

export const texto3j = `
Base de Datos Relacional:
En esta fase se definen las entidades que integran la base de datos relacional con PostgreSQL. Definimos los nombres, tipos de datos y relaciones entre las tablas.`;

export const texto3k = `
Tabla USER:
La tabla user contiene la data que el usuario ingresa en la creación de una cuenta en la aplicación, es lo que va a permitir la validación para el inicio de sesión y la creación de tareas. Los campos de la tabla son:
UserID: será autogenerado, único y funcionará como la llave principal.
Name: nombre del usuario, tipo VARCHAR.
Email: correo del usuario, tipo VARCHAR.
Password: contraseña del usuario, tipo VARCHAR.`;

export const texto3l = `
Tabla TASK:
La tabla task contiene las tareas que el usuario administre, son las que se presentan en la vista principal de la aplicación web.
TaskID: autogenerado, único y funciona como la llave principal.
UserID: llave foránea que permite relacionar la tarea con el usuario al que pertenece, se encuentra en la tabla USER.
Title: título de la tarea, tipo VARCHAR.
Description: descripción de la tarea, tipo VARCHAR.
Status: estado de la tarea, se manejan los diferentes estados con número, de tipo NUMERIC.
Creation_Date: fecha de creación de la tarea, no será ingresada por el usuario será tomada de forma automática, tipo DATE.
Due_Date: fecha de finalización de la tarea, tipo DATE.`;

export const texto3m = `
Base de datos No Relacional:
Para la base de datos no relacional se utiliza MongoDB, una base de datos documental que almacenará la información sobre Users y Task.`;



export const texto4 = `

●	Desarrollo de mockup para un “To-do List” 
Para el caso de ejemplo actual el diseño de los mockups se realizó en la aplicación web Figma, estos representan una guía visual de 
la aplicación.`;


export const texto5 = `
se presenta la pantalla de Login es la primera vista de la aplicación, acá el usuario ingresa las credenciales para poder entrar al  Dashboard de Tareas, si el usuario no tiene cuenta se muestra la opción de Signup here.  `;

export const texto6 = `Se presenta la pantalla Signup contiene los datos requeridos para crear una cuenta, los campos están validados para que acepten texto en formato correo y los campos de password muestran/ocultan la contraseña que el usuario ingrese.  `;

export const texto7 = `se presenta el dashboard de un usuario y si no tiene tareas agregadas se muestra el empty state, la opción 
para agregar una tarea. `;

export const texto8 = `se presenta un modal que se despliega para la creación de tareas con los diferentes campos.    `;

export const texto9 = `se presenta la vista principal de las tareas contenidas por estado (Upcoming, To Do, Doing, Done) en donde 
las tareas pueden ser movidas por el usuario manualmente o de acuerdo a las fechas que se hayan ingresado previamente.  `;

export const texto10 = `se presenta el modal con la información actual de la tarea seleccionada con los campos disponibles 
para editar y la empresa para Guardar Cambios o Borrar Tarea.  `;

export const texto11 = `
Requerimientos técnicos de hardware y software

Para el desarrollo de la aplicación Flytask se pretende levantar seis contenedores con el uso de Docker Compose, aprovechando las 
distintas tecnologías. A continuación, se detalla el hardware requerido por cada una de las tecnologías y se presenta una 
recomendación de hardware para desarrollar Flytask.`;

export const texto11a = `
Requerimientos técnicos de hardware:
  - Procesador: 2.5 GHz o superior.
  - Memoria RAM: 16 GB como mínimo.
  - Espacio en disco: 256 GB SSD como mínimo.
  - Sistema operativo: Windows 10 64-bit (build 19043 o posterior), macOS x 10.10 o posterior, o Ubuntu 18.04 o posterior.`;

export const texto11b = `
Requerimientos técnicos de software:
Visual Studio Code:
  - Sistema operativo: Windows 10 y 11 (64-bit), macOS x, Linux (Debian: Ubuntu Desktop 20.04, Debian 10; 
  Red Hat: Red Hat Enterprise Linux 8, Fedora 36).
  - Procesador: 1.6 GHz o más rápido.
  - Memoria: 1 GB de RAM.
  - Espacio en disco: Visual Studio Code es una descarga pequeña (< 200 MB) y tiene una huella de disco de < 500 MB.`;

export const texto11c = `
Angular:
  - Sistema operativo: Windows 10, macOS x 10.10 (Yosemite) o posterior, o una distribución reciente de Linux 
  (como Ubuntu 18.04 o posterior).
  - Memoria: Al menos 4 GB de RAM.
  - Espacio de almacenamiento: Al menos 10 GB de espacio libre en disco.`;

export const texto11d = `
React:
  - Sistema operativo: Windows 10, macOS x 10.10, o Ubuntu 16.
  - Hardware: Al menos 4 GB de RAM y 10 GB de espacio de almacenamiento.`;

export const texto11e = `
Spring Boot:
  - Procesador: Mínimo Pentium 2 a 266 MHz.
  - RAM: Al menos 128 MB.
  - Espacio en disco: 124 MB para JRE; 2 MB para Java Update; 10MB para la instalación de Maven; 500MB para 
  el repositorio local de Maven.
  - Sistema operativo: JDK 8 o superior para Maven.`;

export const texto11f = `
Django:
  - Sistema operativo: Windows 7 o 10, macOS X 10.11 o superior, Linux: RHEL 6/7, 64-bit (casi todas las 
  bibliotecas también funcionan en Ubuntu).
  - Procesador: Dual-core Intel Core i5 o similar.
  - RAM y espacio libre en disco: 4 GB de RAM, 5 GB de espacio libre en disco.`;

export const texto11g = `
Express.js:
  - Procesador: 1.6 GHz o más rápido.
  - Memoria: 4 GB de RAM.
  - Espacio en disco: 512 MB de espacio libre en disco.
  - Sistemas operativos soportados: macOS, Windows (incluyendo WSL), y Linux.`;

export const texto11h = `
MongoDB:
  - Procesador: 1 GHz.
  - Memoria: 2 GB de RAM.
  - Espacio en disco: 512 MB de HDD.`;

export const texto11i = `
PostgreSQL:
  - Procesador: 1 GHz.
  - Memoria: 2 GB de RAM.
  - Espacio en disco: 512 MB de HDD.`;

export const texto11j = `
Vue.js:
  - Sistema operativo: Windows 10.
  - Procesador: Frecuencia base de 1.8 GHz o superior.
  - Memoria: 4 GB de RAM o más.
  - Espacio de almacenamiento: 75 MB de espacio disponible en disco o más.`;

export const texto11k = `
Docker:
  - Sistema operativo: Windows 10 64-bit: Home o Pro (build 19043 o posterior), Enterprise o Education 
  (build 19042 o posterior). 
  Windows 11 64-bit: Home, Pro, Enterprise, o Education versión 21H2 o más reciente.
  - Procesador: Procesador de 64 bits.
  - Memoria: 4 GB de RAM.
  - Espacio en disco: 100 GB de SSD.`;

export const texto11l = `
Docker Compose:
  - Sistema operativo: Linux, Mac y Windows.
  - Procesador: Procesador de 64 bits.
  - Memoria: 4 GB de RAM.
  - Espacio en disco: Docker Desktop es una descarga pequeña (< 200 MB) y tiene una huella de disco de < 500 MB.
  - Docker Compose se instala con Docker Desktop.`;

export const texto11m = `
Nginx:
  - 512 MB de RAM y 50 MB de espacio libre en disco.
`;


export const texto12 = `
Diseño de la Arquitectura de la aplicación

La arquitectura de la aplicación Flytask se ha diseñado considerando una combinación óptima de tecnologías para el Front End, 
Back End y la base de datos. La característica más importante para el caso de aplicación es que estas tecnologías seleccionadas 
pueden ser independientes, y se configura para interactuar entre sí. Para el caso del ejemplo práctico, se realizará una 
integración de todos con todos, lo que implica que se desarrollarán los seis Back Ends, tres con PostgreSQL y tres con MongoDB, 
y se realizarán tres Front End uno para cada tecnología. Con las 9 aplicaciones creadas se utilizará dockerización, 
reverse proxy para el formateo de las URL, y un balanceador de carga que se configurará en el servidor a la hora de desplegar. 
Esto permitirá que todas las tecnologías de Front End sean capaces de consultar a todas las API.`;

export const texto12a = `
Selección de tecnologías para el Front End de Flytask: 
  - Frameworks a utilizar: Vue, React.`;

export const texto12b = `
Selección de tecnologías para el Back End de Flytask:
  - Spring Boot, Django, Express.`;

export const texto12c = `
Selección de bases de datos de Flytask:
  - NoSQL MongoDB o PostgreSQL.`;

export const texto12d = `
La combinación de estas tecnologías proporciona una solución robusta y flexible para el desarrollo de la aplicación. 
Cada tecnología ha sido seleccionada por su eficiencia, flexibilidad y capacidad para integrarse con otras tecnologías. 
Esta combinación permite que la aplicación sea escalable, mantenible y capaz de proporcionar una experiencia de usuario 
de alta calidad.
`;

export const texto13 = `
Patrones de diseño

A continuación, se detalla el patrón de diseño a utilizar para cada una de las API y cada uno de los Clientes que serán 
desarrollados para Flytask.

Patrón de diseño para Spring Boot y Express.js:
En el caso de Spring Boot y Express.js se aplica un patrón de diseño MVC (Modelo Vista Controlador). Ambos frameworks utilizan 
una estructura de carpetas similar, que será la siguiente:
  - Config: Contiene los archivos de configuración de la API, incluyendo configuraciones específicas como Spring Security.
  - Controller: Carpeta que contiene todas las clases RESTController con las rutas para las consultas HTTP.
  - Model
    - DTO: Contiene las clases de DTO que facilitan la manipulación de datos entre capas.
    - Entities: Contiene las clases de entidades que reflejan la estructura de la base de datos gracias a JPA.
  - Repository: Contiene funciones para interactuar directamente con las entidades y realizar operaciones CRUD.
  - Service
    - Service: Contiene interfaces que definen la estructura de los servicios.
    - ServiceImpl: Implementaciones de los servicios que manejan la lógica de negocio, construyen DTOs y realizan cálculos 
    complejos para inserciones y consultas.
`;

export const texto13a = `
Patrón de diseño para Django:
Para desarrollar una API en Django se utiliza el patrón de diseño MTV (Model Template View):
  - Migrations: Contiene todas las migraciones autogeneradas por Django para configurar la estructura de la base de datos.
  - Utils: Contiene archivos estáticos y funciones de utilidad.
  - Models: Contiene las clases de entidades que se mapean a la base de datos.
  - Views: Contiene la lógica de las llamadas a la API (equivalente a los controladores en otros frameworks).
  - URL: Contiene las rutas utilizadas por las vistas para las consultas HTTP.
  - Apps: Configura la aplicación como un proyecto de Django, cada una con sus propias Migrations, Models, Views, y URLs.
  - Settings: Contiene las configuraciones de conexión a bases de datos, configuraciones de Spring Security y CORS.
`;

export const texto13b = `
Patrón de diseño para React:
Para React se utiliza el patrón Contenedor-Presentador (o Contenedor-Componente):
  - Components
    - Common: Contiene componentes reutilizables como barras de navegación.
    - Feature: Contiene componentes específicos para funcionalidades como gráficos.
  - Containers: Contiene componentes que conectan los componentes presentacionales con la lógica de la aplicación y 
    manejo de datos.
  - Services: Contiene funciones para interactuar con la API utilizando bibliotecas como Axios, proporcionando métodos 
  para operaciones CRUD.
  - Utils: Contiene funciones auxiliares para procesar la información devuelta por la API.
  - Pages: Contiene las páginas principales de la aplicación que llaman a los contenedores y componentes.
  - Assets: Contiene archivos estáticos como imágenes e iconos utilizados por los componentes.
  - Styles: Contiene configuraciones de estilos utilizando bibliotecas como Tailwind.
`;

export const texto14 = `

Al implementar las buenas prácticas de codificación, se utilizan herramientas que facilitan la creación de aplicaciones de alta calidad y seguridad. Estas librerías y frameworks son bloques de funcionalidades probadas a lo largo del tiempo, cuyo código se puede reutilizar fácilmente. Los programadores pueden diseñar operaciones específicas de lógica de negocios utilizando estas herramientas, basándose en los principios SOLID.
`;

export const texto14a = `

En el desarrollo Back End, la implementación de buenas prácticas y el uso de SOLID están presentes a lo largo del framework utilizado. Estos marcos de trabajo proporcionan una base sólida y previamente estudiada, asegurando un código limpio y fácil de mantener. El uso de patrones de diseño garantiza que los archivos y sus responsabilidades estén adecuadamente separados.
`;

export const texto14b = `

- Principio de responsabilidad única:
  - En Spring Boot, se aplica en los servicios que manejan la lógica de negocios.
  - En Django, se ve en las vistas que cumplen funciones similares.
  - En Express, se refleja en middlewares enfocados en tareas específicas como la validación de datos.
`;

export const texto14c = `

- Principio abierto/cerrado:
  - En Spring Boot, aplicado a los repositorios.
  - En Django, a las vistas basadas en clases.
  - En Express, a los middlewares personalizados.
`;

export const texto14d = `

- En Spring Boot, se refleja en la programación basada en interfaces y la inyección automática de dependencias.
- En Django, se aplica en el uso de clases modelos expandibles y heredables.
- En Express, se manifiesta en la modularidad de sus componentes y su facilidad de mantenimiento.
`;

export const texto14e = `

- Principio de segregación de interfaces:
  - Implementado junto con los principios de abierto/cerrado y responsabilidad única.
  
- Principio de inversión de dependencias:
  - Implementado junto con el principio de sustitución de Liskov, garantizando que los módulos de alto nivel 
  no dependan de módulos de bajo nivel.
`;

export const texto14f = `

Para el desarrollo del Front End con React y Vue, se sigue el lineamiento SOLID y se utiliza el concepto de "Clean Architecture". El objetivo es mantener el desarrollo de la aplicación limpio y comprensible para cualquier desarrollador. La estructura de archivos y carpetas debe reflejar claramente las funcionalidades de la aplicación.
`;


export const texto15 = `
En el desarrollo web este principio es muy predominante, ya que debe aislar cada tarea y función 
de cada componente, conexión y página lo más posible; esto permite que se puedan manejar las 
conexiones con los distintos Back Ends disponibles y no requiera de ningún cambio del lado del 
Front End, más allá de la ruta de conexión solicitada. (Casero, 2024)`;

export const texto15a = `Una de las partes que innegablemente siguen este principio, se localizan en la carpeta api,
para ambos desarrollos, en esta se encuentran los archivos que permiten la conexión con el 
Back End que se encargan de manera independiente del manejo y llamada a los métodos disponibles 
para FlyTask, un ejemplo claro del buen uso de SRP* es el uso de un solo archivo llamado Task.ts 
que se encarga del manejo de todos los métodos DELETE, PUT, GET y POST además se separa cada 
método en componentes separados y que su nombre de una breve descripción de lo que se está realizando.`;

export const texto15b = `Las carpetas API contiene los archivos .ts y .js que realizan el mapeo de los endpoints que 
la aplicación web consume, al haber seis Back Ends distintos a los cuales la aplicación puede 
consumir, el tener archivos que permitan el manejo aislado de los endpoints disponibles hace que 
la versatilidad sea posible. Los archivos que realizan esta tarea son el base.api.ts y el base.api.`;


   export const texto16 = `Otro lado de la aplicación en la que se puede observar buen uso de este principio es en la carpeta components, 
en ella se contienen los elementos visuales principales que son renderizados dentro de la aplicación, 
los modales están separados en una subcarpeta y los componentes "grandes" se encuentran dentro de la principal. 
El buen uso de SRP También se ve aplicado en los componentes de la sección modals ya que se contienen 3 
modales diferentes, que a simple vista se podría inducir que basta con desarrollar uno y renderizar según el uso 
que se le vaya a dar. Lo ideal es separar los componentes, ya que cada uno desarrolla una tarea diferente y por 
cuestiones de orden e integridad resulta mejor separarlos.   `;
   
   
   
export const texto17 = `
El principio abierto/cerrado se manifiesta en el desarrollo del Front End a través de la reutilización de componentes. 
En lugar de crear un componente monolítico, se divide la funcionalidad en componentes más pequeños que pueden ser 
utilizados en diferentes partes de la aplicación.
`;

export const texto17a = `
Por ejemplo, se tiene un componente Notification.ts que se encarga de mostrar mensajes de error o éxito después de 
una petición. Este componente puede ser llamado desde cualquier página de la aplicación y mostrar el mensaje deseado. 
Está diseñado para aceptar ciertos parámetros que se pasan durante su llamada en otras partes de la aplicación.
`;

export const texto17b = `
En la página Sign-Up.tsx, se instancia el componente Notification con diferentes personalizaciones como el mensaje, 
el color y el estado de visibilidad, demostrando así cómo un componente puede ser reutilizado con diferentes 
configuraciones sin necesidad de modificar su código base.
`;

export const texto17c = `
Otro ejemplo es el componente AddTaskModal.vue, que se utiliza para la creación de tareas. Cuando se necesita 
comunicar un mensaje, este componente se invoca de manera similar, aprovechando la flexibilidad y 
la extensibilidad del diseño.
`;

export const texto17d = `
Este enfoque permite que los componentes estén abiertos a la extensión mediante la configuración y personalización 
en lugar de la modificación, lo que facilita el mantenimiento y la escalabilidad de la aplicación.
`;


export const texto18 = `El principio de la sustitución de Liskov en el desarrollo Front End asegura que los 
componentes puedan ser reemplazados por otros componentes sin afectar el funcionamiento de la aplicación.
`;

export const texto18a = `Por ejemplo, en la página TaskBoard.tsx, los componentes ListView y KanBan reciben una propiedad llamada tasks. 
Este diseño asegura que estos componentes puedan ser intercambiados por otros que también reciban la misma 
propiedad tasks sin romper la funcionalidad original de la página. Esto facilita la refactorización del 
Front End en caso de que se requieran cambios en los estilos o la estructura general del sitio.
`;

export const texto18b = `En el framework Vue, los componentes ListView y KanbanView reciben las mismas propiedades de TaskData. 
Aunque en la práctica no se intercambian debido a diferencias en diseño y usabilidad, el principio se 
sigue cumpliendo ya que el reemplazo de estos componentes no rompería la aplicación web.
`;

export const texto18c = `Este enfoque permite una mayor flexibilidad y mantenimiento en el desarrollo, ya que se pueden hacer 
cambios y mejoras sin comprometer la funcionalidad existente.
`;



export const texto19 = `El "principio de segregación de interfaz" establece que los usuarios o clientes no deben depender de componentes 
y páginas que no necesitan. En lugar de tener una única página grande que consulte muchos métodos y realice 
todas las tareas, se utilizan múltiples interfaces que realizan tareas específicas dentro de la aplicación. 
Esto significa que las clases solo se ocupan de las tareas relevantes en su contexto, reduciendo la dependencia 
innecesaria entre el código.
`;

export const texto19a = `En el desarrollo Front End de FlyTask, este principio es fundamental. Todo se maneja de manera independiente entre clases, 
métodos y componentes, lo que se evidencia en la estructura de las carpetas donde todo está correctamente aislado.
`;

export const texto19b = `Un buen ejemplo de este principio en FlyTask es el componente TaskAccordion.tsx. Este componente se utiliza para 
mostrar todas las tareas del usuario, independientemente de su estado, fecha y nombre. El componente se llama una sola 
vez y se "dibuja" según las tareas del usuario en la base de datos, evitando renderizaciones innecesarias en el Front End 
y dependiendo del Back End para su actualización.
`;

  

export const texto20 = `Implementación de los patrones de diseño
En FlyTask, los patrones de diseño se implementan desde la arquitectura cliente-servidor, que divide 
la lógica de negocios de la presentación de datos mediante una arquitectura de capas. En estas capas, 
se utilizan patrones de diseño optimizados para sus responsabilidades específicas: MVC para la capa 
de servidor y Screaming Architecture para la capa de clientes en React y Vue.js. Esto permite aplicar 
los principios SOLID y mantener un orden interno en los archivos, facilitando la construcción y 
escalabilidad de la aplicación.
`;

export const texto20a = `Arquitectura en Spring Boot:
La arquitectura de Spring Boot comienza en la carpeta src/main/, que contiene el archivo principal de Java.
`;

export const texto20b = `Arquitectura en Express:
El framework Express sigue un patrón de diseño específico que se refleja en su jerarquía de carpetas.
`;

export const texto20c = `Arquitectura en Django:
En Django, la estructura se organiza como un proyecto general llamado FlyTask, que contiene:

Un archivo settings con las configuraciones de Django y la base de datos.
Un archivo URLs con el mapeo general de las URL.
Carpetas específicas por aplicación, como users y tasks.
Dentro de cada aplicación se encuentran:
`;

export const texto20d = `  - URLs: Contienen las rutas de la API para cada modelo.
  - Views: Contienen las funciones con la lógica de negocio.
  - Models: Mapean cada modelo a la base de datos.
  - Serializers: Contienen funciones para serializar datos.
`;

export const texto20e = `Este patrón de diseño en Django se basa en MVC, con equivalentes en Models, Views, y URLs.
`;

   
export const texto21 = `Implementación de buenas prácticas de seguridad
Las prácticas de seguridad se integran en la base de código de dos maneras.
`;

export const texto21a = `La primera es en la programación manual de patrones que evitan el acceso a datos sensibles y el uso 
de versiones vigentes de las tecnologías (lenguajes, frameworks).
`;

export const texto21b = `La segunda es a través del uso de herramientas de terceros (librerías, primitivos) que implementan
métodos de validación, encriptación y redirección que han sido probados y se actualizan de manera 
constante para responder a las necesidades de los programadores.
`;

export const texto21c = `En el caso de la aplicación se implementan bearer tokens para la autenticación de los usuarios y 
su acceso a la información, y se utilizan librerías como Spring Security del lado del servidor y 
validadores como Yup en la capa de cliente.
`;

export const texto21d = `Desarrollo del Front End
Esta etapa consiste en el desarrollo de un cliente web que utiliza servicios y consume datos desde 
una API que maneja la lógica de negocio de flytask.
`;

export const texto21e = `Para este documento se presentan dos clientes web: uno desarrollado con React (utilizando Typescript)
y uno desarrollado con Vue (utilizando JavaScript) que realizan las mismas funciones con el 
mismo diseño y utilizan patrones que permiten la reutilización de código dentro de sus 
componentes e incluso entre proyectos.
`;

export const texto21f = `Arquitectura de cliente
El cliente web de flytask permite al usuario interactuar con la lógica de negocio para
manejar sus tareas.
`;

export const texto21g = `Este manejo de tareas involucra un conjunto de operaciones que la API realiza al recibir la 
información del usuario.
`;

export const texto21h = `La implementación del cliente debe considerar la comunicación con el servidor y garantizar 
que tenga una estructura reutilizable y comportamiento predecible.
`;

export const texto21i = `De la misma manera, los componentes visuales deben utilizar estructuras que permitan reutilización 
y tengan la segregación suficiente para ser manejables a medida que una aplicación crece en tamaño 
y complejidad.
`;

export const texto21j = `Con el propósito de garantizar los requerimientos anteriores, se utilizan los principios de 
Screaming Architecture en el desarrollo de los proyectos en React y VueJS.
`;
